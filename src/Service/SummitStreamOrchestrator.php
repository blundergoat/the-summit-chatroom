<?php

declare(strict_types=1);

namespace App\Service;

use App\Streaming\CancellationToken;
use Psr\Log\LoggerInterface;
use StrandsPhpClient\Context\AgentContext;
use StrandsPhpClient\Exceptions\AgentErrorException;
use StrandsPhpClient\StrandsClient;
use StrandsPhpClient\Streaming\StreamEvent;
use StrandsPhpClient\Streaming\StreamEventType;
use Symfony\Component\DependencyInjection\Attribute\Autowire;
use Symfony\Component\Mercure\HubInterface;
use Symfony\Component\Mercure\Update;
use Symfony\Component\Uid\Uuid;

/**
 * Streaming variant of the summit orchestrator - streams tokens via Mercure in real-time.
 *
 * Instead of waiting for each agent to finish and returning all text at once (sync mode),
 * this orchestrator streams each token as it's generated by the LLM. The tokens are
 * published to Mercure topics, and the browser receives them via Server-Sent Events (SSE).
 *
 * THE STREAMING FLOW:
 *
 *   Python Agent --(SSE tokens)--► PHP stream() --(Mercure publish)--► Browser EventSource
 *
 *   1. PHP calls stream() on the Python agent (HTTP request with SSE response)
 *   2. Python agent calls the LLM and streams tokens back as SSE events
 *   3. PHP receives each SSE event via the StreamParser
 *   4. PHP publishes each token to a Mercure topic (one topic per persona)
 *   5. Browser's EventSource listener receives the token and appends it to the chat bubble
 *
 * MERCURE TOPICS:
 *   Each agent streams to its own topic so the browser can render them independently:
 *     {topicBase}/{persona}  - Each persona's tokens
 *     {topicBase}/done       - Signal that all agents have finished
 *
 * WHY THIS RUNS AFTER THE RESPONSE (kernel.terminate):
 *   The ChatController dispatches this method via kernel.terminate so that the HTTP response
 *   (with the Mercure topic name) reaches the browser BEFORE streaming begins. This gives
 *   the browser time to set up EventSource listeners. Otherwise, early tokens would be lost.
 */
class SummitStreamOrchestrator
{
    public function __construct(
        #[Autowire(service: 'strands.client.summit')]
        private readonly StrandsClient $strandsClient,
        private readonly HubInterface $hub,
        private readonly LoggerInterface $logger,
        private readonly CancellationToken $cancellationToken,
    ) {
    }

    /**
     * Stream all personas sequentially, publishing each token to Mercure.
     *
     * This method BLOCKS for the full duration of all agent streams.
     * It runs after the HTTP response has been sent (via kernel.terminate).
     *
     * @param string   $message   The user's question
     * @param string   $sessionId Session ID for conversation continuity
     * @param string   $topicBase Base Mercure topic (e.g., "the-summit/{session_id}")
     * @param string[] $personas  Ordered list of persona names to stream
     */
    public function deliberateStreaming(string $message, string $sessionId, string $topicBase, array $personas = []): void
    {
        $correlationId = Uuid::v7()->toRfc4122();
        $streamStartedAt = microtime(true);

        $this->logger->info('summit.streaming.started', [
            'correlation_id' => $correlationId,
            'session_id' => $sessionId,
            'topic_base' => $topicBase,
            'message_length' => mb_strlen($message),
            'personas' => $personas,
        ]);

        foreach ($personas as $persona) {
            $this->streamPersona($message, $sessionId, $topicBase, $persona, $correlationId, $personas);
        }

        $this->publish($topicBase . '/done', [
            'type' => 'all_complete',
            'correlation_id' => $correlationId,
        ]);

        $this->logger->info('summit.streaming.completed', [
            'correlation_id' => $correlationId,
            'session_id' => $sessionId,
            'topic_base' => $topicBase,
            'duration_ms' => (int) round((microtime(true) - $streamStartedAt) * 1000),
        ]);
    }

    /**
     * Stream a single persona and publish events to Mercure.
     *
     * @param string[] $allPersonas Ordered list of all active personas (for metadata)
     */
    private function streamPersona(
        string $message,
        string $sessionId,
        string $topicBase,
        string $persona,
        string $correlationId,
        array $allPersonas,
    ): void {
        $personaStartedAt = microtime(true);
        $topic = $topicBase . '/' . $persona;

        $this->publish($topic, [
            'type' => 'start',
            'persona' => $persona,
            'correlation_id' => $correlationId,
        ]);

        // Cross-runtime metadata contract with strands_agents/api/server.py.
        // These keys are read directly by Python endpoints; renaming them on one side
        // without the other silently breaks persona/objective routing.
        $context = AgentContext::create()
            ->withMetadata('persona', $persona)
            ->withMetadata('correlation_id', $correlationId)
            ->withMetadata('active_personas', $allPersonas);

        $this->logger->info('summit.streaming.persona.started', [
            'correlation_id' => $correlationId,
            'session_id' => $sessionId,
            'persona' => $persona,
            'topic' => $topic,
        ]);

        $eventCounts = [
            'text' => 0,
            'tool_use' => 0,
            'tool_result' => 0,
            'thinking' => 0,
            'complete' => 0,
            'error' => 0,
        ];

        try {
            $result = $this->strandsClient->stream(
                message: $message,
                onEvent: function (StreamEvent $event) use ($topic, $persona, $correlationId, &$eventCounts): ?bool {
                    if ($this->cancellationToken->isCancelled($topic)) {
                        $this->publish($topic, [
                            'type' => 'cancelled',
                            'persona' => $persona,
                            'correlation_id' => $correlationId,
                        ]);

                        return false;
                    }

                    $eventCounts[$event->type->value]++;

                    match ($event->type) {
                        StreamEventType::Text => $this->publish($topic, [
                            'type' => 'text',
                            'persona' => $persona,
                            'content' => $event->text,
                            'correlation_id' => $correlationId,
                        ]),
                        StreamEventType::ToolUse => $this->publish($topic, [
                            'type' => 'tool_use',
                            'persona' => $persona,
                            'tool_name' => $event->toolName,
                            'correlation_id' => $correlationId,
                        ]),
                        StreamEventType::ToolResult => $this->publish($topic, [
                            'type' => 'tool_result',
                            'persona' => $persona,
                            'tool_name' => $event->toolName,
                            'correlation_id' => $correlationId,
                        ]),
                        StreamEventType::Thinking => $this->publish($topic, [
                            'type' => 'thinking',
                            'persona' => $persona,
                            'correlation_id' => $correlationId,
                        ]),
                        StreamEventType::Complete => $this->publish($topic, [
                            'type' => 'complete',
                            'persona' => $persona,
                            'correlation_id' => $correlationId,
                            'has_objective' => $event->hasObjective,
                        ]),
                        StreamEventType::Error => $this->publish($topic, [
                            'type' => 'error',
                            'persona' => $persona,
                            'message' => $event->errorMessage,
                            'correlation_id' => $correlationId,
                        ]),
                        StreamEventType::Citation,
                        StreamEventType::ReasoningSignature,
                        StreamEventType::ReasoningRedacted => null,
                    };

                    return null;
                },
                context: $context,
                sessionId: $sessionId,
            );

            $this->logger->info('summit.streaming.persona.completed', [
                'correlation_id' => $correlationId,
                'session_id' => $sessionId,
                'persona' => $persona,
                'duration_ms' => (int) round((microtime(true) - $personaStartedAt) * 1000),
                'event_counts' => $eventCounts,
                'input_tokens' => $result->usage->inputTokens,
                'output_tokens' => $result->usage->outputTokens,
                'stop_reason' => $result->stopReason?->value,
                'tools_used' => count($result->toolsUsed),
            ]);
        } catch (\Throwable $e) {
            $errorContext = [
                'correlation_id' => $correlationId,
                'session_id' => $sessionId,
                'persona' => $persona,
                'duration_ms' => (int) round((microtime(true) - $personaStartedAt) * 1000),
                'exception_class' => $e::class,
                'exception_message' => $e->getMessage(),
            ];

            if ($e instanceof AgentErrorException) {
                $errorContext['status_code'] = $e->statusCode;
                $errorContext['response_body'] = $e->responseBody;
            }

            $this->logger->error('summit.streaming.persona.failed', $errorContext);

            $this->publish($topic, [
                'type' => 'error',
                'persona' => $persona,
                'message' => $e->getMessage(),
                'correlation_id' => $correlationId,
            ]);
        }
    }

    /**
     * Publish a JSON message to a Mercure topic.
     *
     * @param string              $topic The Mercure topic URI
     * @param array<string, mixed> $data  The event data to JSON-encode and publish
     */
    private function publish(string $topic, array $data): void
    {
        $this->hub->publish(new Update(
            $topic,
            json_encode($data, JSON_THROW_ON_ERROR),
        ));
    }
}
