<?php

declare(strict_types=1);

namespace App\Service;

use Psr\Log\LoggerInterface;
use StrandsPhpClient\Context\AgentContext;
use StrandsPhpClient\StrandsClient;
use StrandsPhpClient\Streaming\StreamEvent;
use StrandsPhpClient\Streaming\StreamEventType;
use Symfony\Component\DependencyInjection\Attribute\Autowire;
use Symfony\Component\Mercure\HubInterface;
use Symfony\Component\Mercure\Update;
use Symfony\Component\Uid\Uuid;

/**
 * Streaming variant of the summit orchestrator - streams tokens via Mercure in real-time.
 *
 * Instead of waiting for each agent to finish and returning all text at once (sync mode),
 * this orchestrator streams each token as it's generated by the LLM. The tokens are
 * published to Mercure topics, and the browser receives them via Server-Sent Events (SSE).
 *
 * THE STREAMING FLOW:
 *
 *   Python Agent --(SSE tokens)--► PHP stream() --(Mercure publish)--► Browser EventSource
 *
 *   1. PHP calls stream() on the Python agent (HTTP request with SSE response)
 *   2. Python agent calls the LLM and streams tokens back as SSE events
 *   3. PHP receives each SSE event via the StreamParser
 *   4. PHP publishes each token to a Mercure topic (one topic per persona)
 *   5. Browser's EventSource listener receives the token and appends it to the chat bubble
 *
 * MERCURE TOPICS:
 *   Each agent streams to its own topic so the browser can render them independently:
 *     {topicBase}/{persona}  - Each persona's tokens
 *     {topicBase}/done       - Signal that all agents have finished
 *
 * WHY THIS RUNS AFTER THE RESPONSE (kernel.terminate):
 *   The ChatController dispatches this method via kernel.terminate so that the HTTP response
 *   (with the Mercure topic name) reaches the browser BEFORE streaming begins. This gives
 *   the browser time to set up EventSource listeners. Otherwise, early tokens would be lost.
 */
class SummitStreamOrchestrator
{
    public function __construct(
        #[Autowire(service: 'strands.client.summit')]
        private readonly StrandsClient $client,
        private readonly HubInterface $hub,
        private readonly LoggerInterface $logger,
    ) {
    }

    /**
     * Stream all personas sequentially, publishing each token to Mercure.
     *
     * This method BLOCKS for the full duration of all agent streams.
     * It runs after the HTTP response has been sent (via kernel.terminate).
     *
     * @param string   $message   The user's question
     * @param string   $sessionId Session ID for conversation continuity
     * @param string   $topicBase Base Mercure topic (e.g., "the-summit/{session_id}")
     * @param string[] $personas  Ordered list of persona names to stream
     */
    public function deliberateStreaming(string $message, string $sessionId, string $topicBase, array $personas = []): void
    {
        $correlationId = Uuid::v7()->toRfc4122();
        $streamStartedAt = microtime(true);

        $this->logger->info('summit.streaming.started', [
            'correlation_id' => $correlationId,
            'session_id' => $sessionId,
            'topic_base' => $topicBase,
            'message_length' => mb_strlen($message),
            'personas' => $personas,
        ]);

        foreach ($personas as $persona) {
            $personaStartedAt = microtime(true);

            $topic = $topicBase . '/' . $persona;

            $this->publish($topic, [
                'type' => 'start',
                'persona' => $persona,
                'correlation_id' => $correlationId,
            ]);

            $context = AgentContext::create()
                ->withMetadata('persona', $persona)
                ->withMetadata('correlation_id', $correlationId)
                ->withMetadata('active_personas', $personas);

            $this->logger->info('summit.streaming.persona.started', [
                'correlation_id' => $correlationId,
                'session_id' => $sessionId,
                'persona' => $persona,
                'topic' => $topic,
            ]);

            $eventCounts = [
                'text' => 0,
                'tool_use' => 0,
                'tool_result' => 0,
                'thinking' => 0,
                'complete' => 0,
                'error' => 0,
            ];

            try {
                $this->client->stream(
                    message: $message,
                    onEvent: function (StreamEvent $event) use ($topic, $persona, $correlationId, &$eventCounts) {
                        $eventCounts[$event->type->value]++;

                        match ($event->type) {
                            StreamEventType::Text => $this->publish($topic, [
                                'type' => 'text',
                                'persona' => $persona,
                                'content' => $event->text,
                                'correlation_id' => $correlationId,
                            ]),
                            StreamEventType::ToolUse => $this->publish($topic, [
                                'type' => 'tool_use',
                                'persona' => $persona,
                                'tool_name' => $event->toolName,
                                'correlation_id' => $correlationId,
                            ]),
                            StreamEventType::ToolResult => $this->publish($topic, [
                                'type' => 'tool_result',
                                'persona' => $persona,
                                'tool_name' => $event->toolName,
                                'correlation_id' => $correlationId,
                            ]),
                            StreamEventType::Thinking => $this->publish($topic, [
                                'type' => 'thinking',
                                'persona' => $persona,
                                'correlation_id' => $correlationId,
                            ]),
                            StreamEventType::Complete => $this->publish($topic, [
                                'type' => 'complete',
                                'persona' => $persona,
                                'correlation_id' => $correlationId,
                                'has_objective' => $event->hasObjective,
                            ]),
                            StreamEventType::Error => $this->publish($topic, [
                                'type' => 'error',
                                'persona' => $persona,
                                'message' => $event->errorMessage,
                                'correlation_id' => $correlationId,
                            ]),
                        };
                    },
                    context: $context,
                    sessionId: $sessionId,
                );

                $this->logger->info('summit.streaming.persona.completed', [
                    'correlation_id' => $correlationId,
                    'session_id' => $sessionId,
                    'persona' => $persona,
                    'duration_ms' => (int) round((microtime(true) - $personaStartedAt) * 1000),
                    'event_counts' => $eventCounts,
                ]);
            } catch (\Throwable $e) {
                $this->logger->error('summit.streaming.persona.failed', [
                    'correlation_id' => $correlationId,
                    'session_id' => $sessionId,
                    'persona' => $persona,
                    'duration_ms' => (int) round((microtime(true) - $personaStartedAt) * 1000),
                    'exception_class' => $e::class,
                    'exception_message' => $e->getMessage(),
                ]);

                $this->publish($topic, [
                    'type' => 'error',
                    'persona' => $persona,
                    'message' => $e->getMessage(),
                    'correlation_id' => $correlationId,
                ]);
            }
        }

        $this->publish($topicBase . '/done', [
            'type' => 'all_complete',
            'correlation_id' => $correlationId,
        ]);

        $this->logger->info('summit.streaming.completed', [
            'correlation_id' => $correlationId,
            'session_id' => $sessionId,
            'topic_base' => $topicBase,
            'duration_ms' => (int) round((microtime(true) - $streamStartedAt) * 1000),
        ]);
    }

    /**
     * Publish a JSON message to a Mercure topic.
     *
     * @param string              $topic The Mercure topic URI
     * @param array<string, mixed> $data  The event data to JSON-encode and publish
     */
    private function publish(string $topic, array $data): void
    {
        $this->hub->publish(new Update(
            $topic,
            json_encode($data, JSON_THROW_ON_ERROR),
        ));
    }
}
